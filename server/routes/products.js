const express = require('express');
const { body, validationResult } = require('express-validator');
const QRCode = require('qrcode');
const db = require('../database/connection');
const router = express.Router();

// Get all products with optional search and filters
router.get('/', (req, res) => {
    try {
        const { search, category, lowStock, limit = 100, offset = 0, all = false } = req.query;
        
        let query = `
            SELECT p.*, c.name as category_name,
                   t_latest.stock_value as latest_transaction_stock_value,
                   t_latest.stock_unit_price as latest_transaction_unit_price
            FROM products p 
            LEFT JOIN categories c ON p.category_id = c.id 
            LEFT JOIN (
                SELECT DISTINCT product_id,
                       FIRST_VALUE(stock_value) OVER (PARTITION BY product_id ORDER BY created_at DESC) as stock_value,
                       FIRST_VALUE(stock_unit_price) OVER (PARTITION BY product_id ORDER BY created_at DESC) as stock_unit_price
                FROM transactions
            ) t_latest ON p.id = t_latest.product_id
            WHERE 1=1
        `;
        const params = [];

        if (search) {
            query += ` AND (p.name LIKE ? OR p.barcode LIKE ? OR p.name_en LIKE ?)`;
            const searchTerm = `%${search}%`;
            params.push(searchTerm, searchTerm, searchTerm);
        }

        if (category) {
            query += ` AND p.category_id = ?`;
            params.push(category);
        }

        if (lowStock === 'true') {
            query += ` AND p.stock <= p.min_stock`;
        }

        query += ` ORDER BY p.name ASC`;
        
        // Â¶ÇÊûúËØ∑Ê±ÇÊâÄÊúâ‰∫ßÂìÅÔºàÁî®‰∫éÊù°Á†ÅÁÆ°ÁêÜÁ≠âÂäüËÉΩÔºâÔºå‰∏çÂ∫îÁî®limitÂíåoffset
        if (all !== 'true') {
            query += ` LIMIT ? OFFSET ?`;
            params.push(parseInt(limit), parseInt(offset));
        }

        const stmt = db.prepare(query);
        const products = stmt.all(...params);

        // Get total count
        let countQuery = `SELECT COUNT(*) as total FROM products p WHERE 1=1`;
        const countParams = [];
        
        if (search) {
            countQuery += ` AND (p.name LIKE ? OR p.barcode LIKE ? OR p.name_en LIKE ?)`;
            const searchTerm = `%${search}%`;
            countParams.push(searchTerm, searchTerm, searchTerm);
        }

        if (category) {
            countQuery += ` AND p.category_id = ?`;
            countParams.push(category);
        }

        if (lowStock === 'true') {
            countQuery += ` AND p.stock <= p.min_stock`;
        }

        const countStmt = db.prepare(countQuery);
        const { total } = countStmt.get(...countParams);

        res.json({
            products,
            total,
            limit: all === 'true' ? total : parseInt(limit),
            offset: parseInt(offset)
        });
    } catch (error) {
        console.error('Get products error:', error);
        res.status(500).json({ error: 'Failed to fetch products' });
    }
});

// ‰∫ßÂìÅÊï∞ÊçÆÂØºÂá∫ÂäüËÉΩ
router.get('/export', (req, res) => {
    try {
        console.log('üîÑ ÂºÄÂßãÂØºÂá∫‰∫ßÂìÅÊï∞ÊçÆ');
        
        // Ëé∑ÂèñÊâÄÊúâ‰∫ßÂìÅÊï∞ÊçÆÔºåÂåÖÂê´Á±ªÂà´‰ø°ÊÅØ
        const query = `
            SELECT 
                p.name,
                p.name_en,
                p.barcode,
                c.name as category_name,
                p.location,
                p.supplier,
                p.description,
                p.stock,
                p.min_stock,
                p.current_unit_price,
                p.total_cost_value,
                p.created_at,
                p.updated_at
            FROM products p
            LEFT JOIN categories c ON p.category_id = c.id
            ORDER BY c.name ASC, p.name ASC
        `;
        
        const products = db.prepare(query).all();
        
        // ÂàõÂª∫CSVÂÜÖÂÆπ
        const headers = [
            'name', 'name_en', 'barcode', 'category_name', 'location', 
            'supplier', 'description', 'stock', 'min_stock', 'current_unit_price',
            'total_cost_value', 'created_at', 'updated_at'
        ];
        
        const csvContent = [
            headers.join(','),
            ...products.map(product => 
                headers.map(header => {
                    const value = product[header] || '';
                    // Â§ÑÁêÜÂåÖÂê´ÈÄóÂè∑ÊàñÊç¢Ë°åÁ¨¶ÁöÑÂÄº
                    return `"${String(value).replace(/"/g, '""')}"`;
                }).join(',')
            )
        ].join('\n');
        
        // ËÆæÁΩÆÂìçÂ∫îÂ§¥
        res.setHeader('Content-Type', 'text/csv; charset=utf-8');
        res.setHeader('Content-Disposition', `attachment; filename="products_export_${new Date().toISOString().split('T')[0]}.csv"`);
        
        console.log(`‚úÖ ÂØºÂá∫ÂÆåÊàêÔºåÂÖ± ${products.length} ‰∏™‰∫ßÂìÅ`);
        res.send('\uFEFF' + csvContent); // Ê∑ªÂä†BOM‰ª•ÊîØÊåÅ‰∏≠Êñá
        
    } catch (error) {
        console.error('‚ùå ‰∫ßÂìÅÂØºÂá∫Â§±Ë¥•:', error);
        res.status(500).json({ error: '‰∫ßÂìÅÊï∞ÊçÆÂØºÂá∫Â§±Ë¥•' });
    }
});

// ‰∫ßÂìÅÊï∞ÊçÆÂØºÂÖ•ÂäüËÉΩ
router.post('/import', require('multer')({ storage: require('multer').memoryStorage() }).single('file'), async (req, res) => {
    try {
        if (!req.file) {
            return res.status(400).json({ success: false, message: 'ËØ∑ÈÄâÊã©Ë¶ÅÂØºÂÖ•ÁöÑÊñá‰ª∂' });
        }
        
        console.log(`üöÄ ÂºÄÂßãÂØºÂÖ•Êñá‰ª∂: ${req.file.originalname}`);
        
        // Ëß£ÊûêCSVÊñá‰ª∂
        const csvContent = req.file.buffer.toString('utf8').replace(/^\uFEFF/, ''); // ÁßªÈô§BOM
        const lines = csvContent.split('\n').filter(line => line.trim());
        
        if (lines.length < 2) {
            return res.status(400).json({ 
                success: false, 
                message: 'Êñá‰ª∂Ê†ºÂºèÈîôËØØÔºöËá≥Â∞ëÈúÄË¶ÅÊ†áÈ¢òË°åÂíå‰∏ÄË°åÊï∞ÊçÆ' 
            });
        }
        
        const headers = lines[0].split(',').map(h => h.replace(/"/g, '').trim());
        const requiredHeaders = ['name', 'category_name', 'stock', 'min_stock', 'current_unit_price'];
        
        // Ê£ÄÊü•ÂøÖÈúÄÁöÑÂàó
        const missingHeaders = requiredHeaders.filter(header => !headers.includes(header));
        if (missingHeaders.length > 0) {
            return res.status(400).json({
                success: false,
                message: `Áº∫Â∞ëÂøÖÈúÄÁöÑÂàó: ${missingHeaders.join(', ')}`
            });
        }
        
        let successCount = 0;
        let errorCount = 0;
        const errors = [];
        
        // ÂºÄÂßã‰∫ãÂä°
        const transaction = db.transaction(() => {
            for (let i = 1; i < lines.length; i++) {
                try {
                    const values = lines[i].split(',').map(v => v.replace(/^"|"$/g, '').trim());
                    
                    if (values.length !== headers.length) {
                        errorCount++;
                        errors.push(`Á¨¨${i + 1}Ë°å: ÂàóÊï∞‰∏çÂåπÈÖç`);
                        continue;
                    }
                    
                    // ÊûÑÂª∫‰∫ßÂìÅÊï∞ÊçÆÂØπË±°
                    const productData = {};
                    headers.forEach((header, index) => {
                        productData[header] = values[index] || null;
                    });
                    
                    // Êü•ÊâæÊàñÂàõÂª∫Á±ªÂà´
                    let categoryId = null;
                    if (productData.category_name) {
                        let category = db.prepare('SELECT id FROM categories WHERE name = ?').get(productData.category_name);
                        if (!category) {
                            const insertCategory = db.prepare('INSERT INTO categories (name) VALUES (?)');
                            const result = insertCategory.run(productData.category_name);
                            categoryId = result.lastInsertRowid;
                        } else {
                            categoryId = category.id;
                        }
                    }
                    
                    // ÊèíÂÖ•ÊàñÊõ¥Êñ∞‰∫ßÂìÅ
                    const insertProduct = db.prepare(`
                        INSERT INTO products (
                            name, name_en, barcode, category_id, location, supplier, 
                            description, stock, min_stock, price, current_unit_price, 
                            total_cost_value, created_at, updated_at
                        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
                    `);
                    
                    const stock = parseFloat(productData.stock) || 0;
                    const unitPrice = parseFloat(productData.current_unit_price) || 0;
                    const totalValue = stock * unitPrice;
                    
                    insertProduct.run(
                        productData.name,
                        productData.name_en || null,
                        productData.barcode || null,
                        categoryId,
                        productData.location || null,
                        productData.supplier || null,
                        productData.description || null,
                        stock,
                        parseFloat(productData.min_stock) || 0,
                        unitPrice, // priceÂ≠óÊÆµ
                        unitPrice, // current_unit_priceÂ≠óÊÆµ  
                        totalValue
                    );
                    
                    successCount++;
                } catch (error) {
                    errorCount++;
                    errors.push(`Á¨¨${i + 1}Ë°å: ${error.message}`);
                }
            }
        });
        
        transaction();
        
        console.log(`‚úÖ ÂØºÂÖ•ÂÆåÊàê: ÊàêÂäü${successCount}‰∏™, Â§±Ë¥•${errorCount}‰∏™`);
        
        res.json({
            success: true,
            message: `ÂØºÂÖ•ÂÆåÊàê: ÊàêÂäü${successCount}‰∏™‰∫ßÂìÅ, Â§±Ë¥•${errorCount}‰∏™`,
            details: {
                successCount,
                errorCount,
                errors: errors.slice(0, 10) // Âè™ËøîÂõûÂâç10‰∏™ÈîôËØØ
            }
        });
        
    } catch (error) {
        console.error('‚ùå ‰∫ßÂìÅÂØºÂÖ•Â§±Ë¥•:', error);
        res.status(500).json({ 
            success: false, 
            message: '‰∫ßÂìÅÊï∞ÊçÆÂØºÂÖ•Â§±Ë¥•',
            error: error.message 
        });
    }
});

// Get product by ID or barcode
router.get('/:identifier', (req, res) => {
    try {
        const { identifier } = req.params;
        
        // Try to find by ID first, then by barcode
        let stmt = db.prepare(`
            SELECT p.*, c.name as category_name 
            FROM products p 
            LEFT JOIN categories c ON p.category_id = c.id 
            WHERE p.id = ? OR p.barcode = ?
        `);
        
        const product = stmt.get(identifier, identifier);
        
        if (!product) {
            return res.status(404).json({ error: 'Product not found' });
        }

        res.json(product);
    } catch (error) {
        console.error('Get product error:', error);
        res.status(500).json({ error: 'Failed to fetch product' });
    }
});

//Create new product
router.post('/', [
    body('name').isLength({ min: 1 }).withMessage('Product name is required'),
    body('category_id').notEmpty().withMessage('Category is required').isInt({ min: 1 }).withMessage('Category must be a valid ID'),
    body('barcode').optional({ checkFalsy: true }).isLength({ min: 1 }).withMessage('Barcode must not be empty if provided'),
    body('stock').isFloat({ min: 0 }).withMessage('Stock must be a positive number'),
    body('min_stock').isFloat({ min: 0 }).withMessage('Minimum stock must be a positive number'),
    body('price').optional().isFloat({ min: 0 }).withMessage('Price must be a positive number')
], (req, res) => {
    try {
        console.log('Create product request body:', JSON.stringify(req.body, null, 2));
        
        const errors = validationResult(req);
        if (!errors.isEmpty()) {
            console.log('Validation errors:', errors.array());
            return res.status(400).json({ errors: errors.array() });
        }

        const {
            name,
            name_en,
            barcode,
            category_id,
            location,
            supplier,
            description,
            stock,
            min_stock,
            price,
            current_unit_price,
            total_cost_value,
            barcode_image,
            qr_code_image,
            barcode_updated_at
        } = req.body;

        // È¢ùÂ§ñÈ™åËØÅÔºöÁ°Æ‰øùcategory_id‰∏ç‰∏∫Á©∫
        if (!category_id || category_id === '' || category_id === null || category_id === undefined) {
            return res.status(400).json({ 
                error: '‰∫ßÂìÅÁ±ªÂà´‰∏∫ÂøÖÂ°´È°πÔºåËØ∑ÈÄâÊã©‰∏Ä‰∏™Á±ªÂà´',
                errors: [{ field: 'category_id', message: 'Category is required' }]
            });
        }

        // Ê£ÄÊü•‰∫ßÂìÅÂêçÁß∞ÊòØÂê¶Â∑≤Â≠òÂú®
        const nameCheckStmt = db.prepare(`SELECT id FROM products WHERE name = ?`);
        const existingProduct = nameCheckStmt.get(name);
        if (existingProduct) {
            return res.status(400).json({ 
                error: `‰∫ßÂìÅÂêçÁß∞"${name}"Â∑≤Â≠òÂú®Ôºå‰∫ßÂìÅÂêçÁß∞ÂøÖÈ°ªÂîØ‰∏Ä` 
            });
        }

        // È™åËØÅÁ±ªÂà´ÊòØÂê¶Â≠òÂú®
        if (category_id) {
            const categoryCheckStmt = db.prepare(`SELECT id FROM categories WHERE id = ?`);
            const existingCategory = categoryCheckStmt.get(category_id);
            if (!existingCategory) {
                return res.status(400).json({ 
                    error: `Á±ªÂà´ID"${category_id}"‰∏çÂ≠òÂú®ÔºåËØ∑ÈÄâÊã©ÊúâÊïàÁöÑÁ±ªÂà´` 
                });
            }
        }

        // Â¶ÇÊûúÊèê‰æõ‰∫ÜÂçï‰ª∑ÂíåÂ∫ìÂ≠òÔºå‰ΩÜÊ≤°ÊúâÊèê‰æõtotal_cost_valueÔºåÂàôËá™Âä®ËÆ°ÁÆó
        let calculatedTotalCostValue = total_cost_value || 0;
        if ((price || current_unit_price) && stock && (!total_cost_value && total_cost_value !== 0)) {
            const unitPrice = current_unit_price || price || 0;
            calculatedTotalCostValue = parseFloat((unitPrice * stock).toFixed(2));
        }

        // Â¶ÇÊûúÊ≤°Êúâcurrent_unit_price‰ΩÜÊúâpriceÔºåÂàô‰ΩøÁî®price‰Ωú‰∏∫current_unit_price
        const finalCurrentUnitPrice = current_unit_price || price || 0;

        const stmt = db.prepare(`
            INSERT INTO products 
            (name, name_en, barcode, category_id, location, supplier, description, stock, min_stock, price, current_unit_price, total_cost_value, barcode_image, qr_code_image, barcode_updated_at) 
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `);

        const result = stmt.run(
            name,
            name_en || null,
            barcode || null,  // ÂÖÅËÆ∏Êù°Á†Å‰∏∫Á©∫
            category_id || null,
            location || null,
            supplier || null,
            description || null,
            0, // Êñ∞‰∫ßÂìÅÂ∫ìÂ≠òÂßãÁªà‰ªé0ÂºÄÂßãÔºåÈÄöËøá‰∫§ÊòìËÆ∞ÂΩïÊù•Êõ¥Êñ∞Â∫ìÂ≠ò
            min_stock || 0,
            0, // ÂàùÂßã‰ª∑Ê†º‰∏∫0ÔºåÈÄöËøáÂÖ•Â∫ì‰∫§ÊòìÊù•ËÆæÂÆö‰ª∑Ê†º
            0, // ÂàùÂßãÂçï‰ª∑‰∏∫0
            0, // ÂàùÂßãÂ∫ìÂ≠ò‰ª∑ÂÄº‰∏∫0
            barcode_image || null,
            qr_code_image || null,
            barcode_updated_at || null
        );

        // Get the created product
        const getStmt = db.prepare(`
            SELECT p.*, c.name as category_name 
            FROM products p 
            LEFT JOIN categories c ON p.category_id = c.id 
            WHERE p.id = ?
        `);
        const product = getStmt.get(result.lastInsertRowid);

        res.status(201).json(product);
    } catch (error) {
        console.error('Create product error:', error);
        if (error.code === 'SQLITE_CONSTRAINT_UNIQUE') {
            return res.status(400).json({ error: 'Product with this barcode already exists' });
        }
        res.status(500).json({ error: 'Failed to create product' });
    }
});

// Update product
router.put('/:id', [
    body('name').isLength({ min: 1 }).withMessage('Product name is required'),
    body('barcode').optional({ checkFalsy: true }).isLength({ min: 1 }).withMessage('Barcode must not be empty if provided'),
    body('stock').isFloat({ min: 0 }).withMessage('Stock must be a positive number'),
    body('min_stock').isFloat({ min: 0 }).withMessage('Minimum stock must be a positive number'),
    body('price').optional().isFloat({ min: 0 }).withMessage('Price must be a positive number')
], (req, res) => {
    try {
        const errors = validationResult(req);
        if (!errors.isEmpty()) {
            return res.status(400).json({ errors: errors.array() });
        }

        const { id } = req.params;
        const {
            name,
            name_en,
            barcode,
            category_id,
            location,
            supplier,
            description,
            stock,
            min_stock,
            price,
            current_unit_price,
            total_cost_value,
            barcode_image,
            qr_code_image,
            barcode_updated_at
        } = req.body;

        // Ê£ÄÊü•‰∫ßÂìÅÂêçÁß∞ÊòØÂê¶Â∑≤Ë¢´ÂÖ∂‰ªñ‰∫ßÂìÅ‰ΩøÁî®
        const nameCheckStmt = db.prepare(`SELECT id FROM products WHERE name = ? AND id != ?`);
        const existingProduct = nameCheckStmt.get(name, id);
        if (existingProduct) {
            return res.status(400).json({ 
                error: `‰∫ßÂìÅÂêçÁß∞"${name}"Â∑≤Ë¢´ÂÖ∂‰ªñ‰∫ßÂìÅ‰ΩøÁî®Ôºå‰∫ßÂìÅÂêçÁß∞ÂøÖÈ°ªÂîØ‰∏Ä` 
            });
        }

        // Â¶ÇÊûúÊèê‰æõ‰∫ÜÂçï‰ª∑ÂíåÂ∫ìÂ≠òÔºå‰ΩÜÊ≤°ÊúâÊèê‰æõtotal_cost_valueÔºåÂàôËá™Âä®ËÆ°ÁÆó
        let calculatedTotalCostValue = total_cost_value;
        if ((price || current_unit_price) && stock && total_cost_value === undefined) {
            const unitPrice = current_unit_price || price || 0;
            calculatedTotalCostValue = parseFloat((unitPrice * stock).toFixed(2));
        }

        // Â¶ÇÊûúÊ≤°Êúâcurrent_unit_price‰ΩÜÊúâpriceÔºåÂàô‰ΩøÁî®price‰Ωú‰∏∫current_unit_price
        const finalCurrentUnitPrice = current_unit_price !== undefined ? current_unit_price : (price || 0);

        const stmt = db.prepare(`
            UPDATE products 
            SET name = ?, name_en = ?, barcode = ?, category_id = ?, location = ?, 
                supplier = ?, description = ?, stock = ?, min_stock = ?, price = ?,
                current_unit_price = ?, total_cost_value = ?,
                barcode_image = ?, qr_code_image = ?, barcode_updated_at = ?,
                updated_at = CURRENT_TIMESTAMP 
            WHERE id = ?
        `);

        const result = stmt.run(
            name,
            name_en || null,
            barcode || null,  // ÂÖÅËÆ∏Êù°Á†Å‰∏∫Á©∫
            category_id || null,
            location || null,
            supplier || null,
            description || null,
            stock || 0,
            min_stock || 0,
            price || 0,
            parseFloat((finalCurrentUnitPrice || 0).toFixed(2)),
            parseFloat((calculatedTotalCostValue || 0).toFixed(2)),
            barcode_image || null,
            qr_code_image || null,
            barcode_updated_at || null,
            id
        );

        if (result.changes === 0) {
            return res.status(404).json({ error: 'Product not found' });
        }

        // Get the updated product
        const getStmt = db.prepare(`
            SELECT p.*, c.name as category_name 
            FROM products p 
            LEFT JOIN categories c ON p.category_id = c.id 
            WHERE p.id = ?
        `);
        const product = getStmt.get(id);

        res.json(product);
    } catch (error) {
        console.error('Update product error:', error);
        if (error.code === 'SQLITE_CONSTRAINT_UNIQUE') {
            return res.status(400).json({ error: 'Product with this barcode already exists' });
        }
        res.status(500).json({ error: 'Failed to update product' });
    }
});

// Delete product
router.delete('/:id', (req, res) => {
    try {
        const { id } = req.params;
        
        // First check if product exists
        const checkStmt = db.prepare('SELECT id FROM products WHERE id = ?');
        const existingProduct = checkStmt.get(id);
        
        if (!existingProduct) {
            return res.status(404).json({ error: 'Product not found' });
        }
        
        // Check for foreign key constraints - delete related transactions first
        const deleteTransactionsStmt = db.prepare('DELETE FROM transactions WHERE product_id = ?');
        deleteTransactionsStmt.run(id);
        
        // Now delete the product
        const stmt = db.prepare('DELETE FROM products WHERE id = ?');
        const result = stmt.run(id);

        if (result.changes === 0) {
            return res.status(404).json({ error: 'Product not found' });
        }

        res.json({ message: 'Product deleted successfully' });
    } catch (error) {
        console.error('Delete product error:', error);
        console.error('Error details:', error.code, error.message);
        res.status(500).json({ error: 'Failed to delete product: ' + error.message });
    }
});

// Generate QR code for product
router.get('/:id/qrcode', async (req, res) => {
    try {
        const { id } = req.params;
        
        const stmt = db.prepare('SELECT * FROM products WHERE id = ?');
        const product = stmt.get(id);
        
        if (!product) {
            return res.status(404).json({ error: 'Product not found' });
        }

        const qrData = {
            id: product.id,
            name: product.name,
            barcode: product.barcode,
            timestamp: new Date().toISOString()
        };

        const qrCodeDataURL = await QRCode.toDataURL(JSON.stringify(qrData), {
            width: 200,
            margin: 1,
            errorCorrectionLevel: 'M'
        });

        res.json({
            qrCode: qrCodeDataURL,
            data: qrData
        });
    } catch (error) {
        console.error('QR code generation error:', error);
        res.status(500).json({ error: 'Failed to generate QR code' });
    }
});

// Get product statistics
router.get('/stats/overview', (req, res) => {
    try {
        const totalProducts = db.prepare('SELECT COUNT(*) as count FROM products').get().count;
        const lowStockItems = db.prepare('SELECT COUNT(*) as count FROM products WHERE stock <= min_stock').get().count;
        const totalValue = db.prepare('SELECT SUM(COALESCE(total_cost_value, 0)) as total FROM products').get().total || 0;
        
        const todayTransactions = db.prepare(`
            SELECT COUNT(*) as count 
            FROM transactions 
            WHERE DATE(created_at) = DATE('now')
        `).get().count;

        res.json({
            totalProducts,
            lowStockItems,
            todayTransactions,
            totalValue
        });
    } catch (error) {
        console.error('Get stats error:', error);
        res.status(500).json({ error: 'Failed to fetch statistics' });
    }
});

// Get product statistics for dashboard
router.get('/stats', (req, res) => {
    try {
        const totalProducts = db.prepare('SELECT COUNT(*) as count FROM products').get().count;
        const lowStockItems = db.prepare('SELECT COUNT(*) as count FROM products WHERE stock <= min_stock').get().count;
        
        // Get today's transactions
        const today = new Date().toISOString().split('T')[0];
        const todayTransactions = db.prepare(`
            SELECT COUNT(*) as count 
            FROM transactions 
            WHERE DATE(created_at) = ?
        `).get(today).count;
        
        // Calculate total inventory value
        const totalValue = db.prepare('SELECT SUM(COALESCE(total_cost_value, 0)) as total FROM products').get().total || 0;
        
        res.json({
            totalProducts: totalProducts,
            lowStockItems: lowStockItems,
            todayTransactions: todayTransactions,
            totalValue: Math.round(totalValue * 100) / 100
        });
    } catch (error) {
        console.error('Stats error:', error);
        res.status(500).json({ error: 'Failed to get stats' });
    }
});

// Search products endpoint
router.get('/search', (req, res) => {
    try {
        const { q } = req.query;
        if (!q) {
            return res.json([]);
        }

        const searchQuery = `
            SELECT p.*, c.name as category_name 
            FROM products p 
            LEFT JOIN categories c ON p.category_id = c.id 
            WHERE p.name LIKE ? OR p.barcode LIKE ? OR p.name_en LIKE ? OR c.name LIKE ?
            ORDER BY p.name ASC
            LIMIT 10
        `;
        
        const searchTerm = `%${q}%`;
        const stmt = db.prepare(searchQuery);
        const results = stmt.all(searchTerm, searchTerm, searchTerm, searchTerm);

        res.json(results);
    } catch (error) {
        console.error('Search error:', error);
        res.status(500).json({ error: 'Failed to search products' });
    }
});

// Get enhanced statistics with growth data
router.get('/stats/dashboard', (req, res) => {
    try {
        // Current statistics
        const totalProducts = db.prepare('SELECT COUNT(*) as count FROM products').get().count;
        const lowStockItems = db.prepare('SELECT COUNT(*) as count FROM products WHERE stock <= min_stock').get().count;
        const totalValue = db.prepare('SELECT SUM(COALESCE(total_cost_value, 0)) as total FROM products').get().total || 0;
        
        const todayTransactions = db.prepare(`
            SELECT COUNT(*) as count 
            FROM transactions 
            WHERE DATE(created_at) = DATE('now')
        `).get().count;

        // Growth calculations
        // Monthly change (comparing to last month)
        const lastMonthProducts = db.prepare(`
            SELECT COUNT(DISTINCT product_id) as count 
            FROM transactions 
            WHERE created_at >= DATE('now', '-1 month', 'start of month') 
            AND created_at < DATE('now', 'start of month')
        `).get().count;
        
        const monthlyChange = lastMonthProducts > 0 
            ? Math.round(((totalProducts - lastMonthProducts) / lastMonthProducts) * 100 * 100) / 100
            : 0;

        // Transaction growth (comparing today to yesterday)
        const yesterdayTransactions = db.prepare(`
            SELECT COUNT(*) as count 
            FROM transactions 
            WHERE DATE(created_at) = DATE('now', '-1 day')
        `).get().count;
        
        const transactionGrowth = yesterdayTransactions > 0
            ? Math.round(((todayTransactions - yesterdayTransactions) / yesterdayTransactions) * 100 * 100) / 100
            : (todayTransactions > 0 ? 100 : 0);

        // Value growth (comparing current month to last month)
        const lastMonthValue = db.prepare(`
            SELECT SUM(t.quantity * COALESCE(p.price, 0)) as total 
            FROM transactions t
            JOIN products p ON t.product_id = p.id
            WHERE t.type = 'IN' 
            AND t.created_at >= DATE('now', '-1 month', 'start of month') 
            AND t.created_at < DATE('now', 'start of month')
        `).get().total || 0;
        
        const currentMonthValue = db.prepare(`
            SELECT SUM(t.quantity * COALESCE(p.price, 0)) as total 
            FROM transactions t
            JOIN products p ON t.product_id = p.id
            WHERE t.type = 'IN' 
            AND t.created_at >= DATE('now', 'start of month')
        `).get().total || 0;
        
        const valueGrowth = lastMonthValue > 0
            ? Math.round(((currentMonthValue - lastMonthValue) / lastMonthValue) * 100 * 100) / 100
            : (currentMonthValue > 0 ? 100 : 0);

        res.json({
            totalProducts,
            lowStockItems,
            todayTransactions,
            totalValue: Math.round(totalValue * 100) / 100,
            monthlyChange,
            transactionGrowth,
            valueGrowth
        });
    } catch (error) {
        console.error('Get enhanced stats error:', error);
        res.status(500).json({ error: 'Failed to fetch enhanced statistics' });
    }
});

module.exports = router;
